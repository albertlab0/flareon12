// Decompiled by Gemini from the provided bytecode
// Function and parameter names have been restored using the provided ABI.

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract DecompiledTripleXOR {

    /**
     * @notice This function encrypts a given plaintext string using a triple-XOR
     *         cipher. It derives three separate 32-byte keys from the initial
     *         prime and time inputs, and then applies them sequentially.
     * @dev The function is 'pure', meaning its output is determined solely by
     *      its inputs, without reading from or writing to the blockchain state.
     * @param _primeFromLcg A number, likely a prime generated by an LCG, used as a seed.
     * @param _conversationTime A number, likely a timestamp, used as a second seed.
     * @param _plaintext The string data to be encrypted. Note: only the first
     *                   32 bytes of the string will be used.
     * @return A 32-byte value representing the encrypted ciphertext.
     */
    function encrypt(
        uint256 _primeFromLcg,
        uint256 _conversationTime,
        string memory _plaintext
    ) public pure returns (bytes32) {
        
        // --- Key Derivation ---

        // Derive the first key (key1) by hashing the initial seeds together.
        bytes32 key1 = keccak256(abi.encodePacked(_primeFromLcg, _conversationTime));

        // Derive the second key (key2) by hashing the first key.
        bytes32 key2 = keccak256(abi.encodePacked(key1));

        // Derive the third key (key3) by hashing the second key.
        bytes32 key3 = keccak256(abi.encodePacked(key2));

        // --- Plaintext Preparation ---

        // Convert the input string to bytes and load the first 32 bytes into
        // a bytes32 variable. If the string is shorter than 32 bytes, the
        // remaining bytes will be padded with zeros.
        bytes32 plaintextBytes;
        assembly {
            plaintextBytes := mload(add(_plaintext, 0x20))
        }

        // --- Encryption ---

        // Apply the triple-XOR cipher. The plaintext is XORed sequentially
        // with each of the three derived keys.
        bytes32 ciphertext = plaintextBytes ^ key1 ^ key2 ^ key3;

        return ciphertext;
    }
}
